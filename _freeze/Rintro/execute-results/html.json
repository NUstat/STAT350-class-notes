{
  "hash": "9f934ed32c4e442a0ca9b1d266d33695",
  "result": {
    "markdown": "---\ntitle: \"R: Introduction\"\nformat:\n    html:\n      toc: true\n      self-contained: true\neditor_options: \n  chunk_output_type: console\n---\n\n\n## Installing R\n\nGo to the The Comprehensive R Archive Network (CRAN): https://cran.r-project.org/\n\n![Rcran](C:/Users/akl0407/Desktop/Courses/2023/Fall 2023/STAT350 Fall 2023/STAT350-class-notes/images/Rcran.jpg)\n\nUnder \"Download and Install R,\" choose \"Linux,\" \"MacOS X\" or \"Windows.\" If you choose Windows, on the next page choose \"base,\" and on the following page choose \"Download R 4.3.1 for Windows\" to download the setup program.\n\nIf you choose MacOS X or Linux you will need to read through the instructions to find the downloads you need for your machine.\n\nOnce you have downloaded the setup program, execute it and follow the instructions for installing R on your system. If you have an earlier version of R already installed, you may continue to use it, or you can uninstall it and then install the most recent version, which is R 4.3.1.\n\n## Installing RStudio\n\nhttps://rstudio.com/products/rstudio/download/\n\nChoose your version: RStudio Desktop, Open Source License, Free. After you install RStudio, you can double click on it and open:\n\n**1. Base case:** This is the simplest case that can be answered directly, and the function does not call itself.\n\n**2. Recursive case:** This is a relatively more complex case that cannot be answered directly, but can be described as a smaller instance of the same problem. In this case, the function calls itself to answer the smaller problem.\n\nBelow is an example, where we defined a function that computes the factorial of an integer by recursion.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfactorial<-function(n)\n{\n  if(n==1)      #Base case\n  {\n      return(1)  \n  }        \n  return(n*factorial(n-1)) #Recursive case\n}\nfactorial(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 120\n```\n:::\n:::\n\n\nIn the above example, the case $n=1$ is the base case, where the function does not need to call itself, and returns 1. All other cases, where $n>1$, and $n \\in \\mathbb{Z}$ are recursive cases, where the function calls itself with a smaller instance of the same problem.\n\nA recursive function must satisfy the following conditions:\n\n1.  There must be a case for all valid inputs.\n\n2.  There must be a base case that makes no recursive calls.\n\n3.  When the function makes a recursive call, it should be to a simpler instance and make forward progress towards the base case.\n\n**Example:** Write a recursive function that returns the $n^{th}$ term of the Fibonacci sequence, where $n$ is an integer, and $n>0$. In a Fibonacci sequence, each number is the sum of the preceding two numbers, and the sequence starts from $0,1$. The sequence is as follows:\n\n$0, 1, 1, 2, 3, 5, 8, 13, 21, ...$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfibonacci<-function(n)\n{\n  if(n==0 | n==1){  #Base case\n    return(n)\n  }\n  return(fibonacci(n-1)+fibonacci(n-2))  #Recursive case\n}\n#The function `fibonacci` prints the n+1th term of the fibonacci sequence when `n` is passed as an argument. Thus, we need to reduce `n` by 1 to print the nth term of the sequence. The function `nth_term` reduces `n` by 1 before passing `n` to the function `fibonacci()`.\nnth_term<-function(N)\n{\n  fibonacci(N-1)\n}\nnth_term(7)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8\n```\n:::\n:::\n\n\n### Practice exercise 1\n\nWrite a recursive function that computes the sum of squares of the first $N$ natural numbers, where $N$ is a parameter to the function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsquares<-function(N)\n{\n  if(N==1)  #Base case\n  {\n    return(1)\n  }else{    #Recursive case\n    return(N**2+squares(N-1))\n  }\n}\nsquares(10)\n```\n:::\n\n\n### Practice exercise 2\n\nWrite a function that counts the occurrence of digit $k$ in a given integer $n$ using recursion. The function has $n$ and $k$ as parameters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfreq_digits<-function(n,d)\n{\n  if(n==0)\n  {\n    return(0)\n  }\n  digit = n%%10\n  n_int = as.integer(n/10)\n  if(digit==d)\n  {\n    return(1+freq_digits(n_int,d))\n  }\n  return(freq_digits(n_int,d))\n}\nfreq_digits(8670800,0)\n```\n:::\n\n\n### Practice exercise 3\n\nUse recursion to write a function that accepts a word as an argument, and returns `TRUE` if the word is a palindrome, otherwise returns `FALSE`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nword<-'racecar'\npalindrome<-function(word)\n{\n  if(nchar(word)<=1)\n  {\n    return(TRUE)\n  }else if(substr(word,1,1)==substr(word,nchar(word),nchar(word)))\n  {\n    palindrome(substr(word,2,nchar(word)-1))\n  }else{\n    return(FALSE)\n  }\n}\npalindrome(word)\n```\n:::\n\n\n## Recursion vs iteration\n\nRecursion is typically used when the problem is naturally recursive (for e.g., generating a Fibonacci sequence), or the data is naturally recursive ( for e.g., filesystem). Recursive solutions can be easy to read and understand as compared to the corresponding iterative solution.\n\nOne downside of recursion is that it may take more space than an iterative solution. Building up a stack of recursive calls consumes memory temporarily, and the stack is limited in size, which may become a limit on the size of the problem that the recursive implementation can solve.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}